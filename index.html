<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Para Ti</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d0f20; /* Color de fondo azul oscuro para el cielo */
        }
        .message-container {
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInAndSlideUp 2s forwards 4s; /* Retraso para que la animación de la flor termine */
        }
        @keyframes fadeInAndSlideUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen overflow-hidden text-white">

    <!-- Contenedor del Canvas -->
    <canvas id="flowersCanvas" class="absolute inset-0 z-0"></canvas>

    <!-- Contenedor del Mensaje -->
    <div class="message-container z-10 text-center px-6">
        <h1 class="text-4xl sm:text-5xl font-bold mb-4">Para la chica más hermosa del mundo</h1>
        <p class="text-xl sm:text-2xl font-light">
            Estas flores crecen para recordarte la luz y la alegría que traes a mi vida. <br class="hidden sm:block"> Me gustas mucho.
        </p>
    </div>

    <script>
        const canvas = document.getElementById('flowersCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        const numFlowers = 25;
        const flowers = [];
        const numStars = 100;
        const stars = [];

        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            if (stars.length === 0) {
                for (let i = 0; i < numStars; i++) {
                    stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        radius: Math.random() * 1.5,
                        twinkleSpeed: Math.random() * 0.05 + 0.01,
                        twinkle: Math.random() * Math.PI * 2
                    });
                }
            }
        }

        // Dibuja una flor en el canvas
        function drawFlower(flower) {
            ctx.save();
            ctx.translate(flower.x, flower.y);
            ctx.rotate(flower.rotation);
            ctx.scale(flower.currentScale, flower.currentScale);
            
            // Dibuja el tallo
            ctx.beginPath();
            if (flower.isMain) {
                // Tallo más detallado y grueso para la flor principal
                const gradient = ctx.createLinearGradient(0, 0, 0, -flower.stemLength);
                gradient.addColorStop(0, '#22c55e');
                gradient.addColorStop(1, '#15803d');
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 5 / flower.currentScale;
            } else {
                ctx.strokeStyle = '#22c55e';
                ctx.lineWidth = 2 / flower.currentScale;
            }
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -flower.stemLength);
            ctx.stroke();

            // Dibuja la flor en la punta del tallo
            ctx.translate(0, -flower.stemLength);

            // Dibuja la flor principal de forma más detallada
            if (flower.isMain) {
                const petalProgress = flower.bloomProgress;
                const numLayers = 3;
                
                // Capas de pétalos
                for (let layer = 0; layer < numLayers; layer++) {
                    const numPetalsInLayer = 10 + layer * 2;
                    const baseAngle = (Math.PI / 8) * layer;
                    const petalColor = `hsl(48, 96%, ${90 - layer * 10}%)`;

                    for (let i = 0; i < numPetalsInLayer; i++) {
                        ctx.save();
                        const angle = (i / numPetalsInLayer) * Math.PI * 2 + baseAngle;
                        ctx.rotate(angle);

                        // Curva de Bézier para la forma del pétalo
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        
                        const petalLength = 40 * petalProgress;
                        const controlPointOffset = 20;

                        ctx.bezierCurveTo(
                            controlPointOffset, -petalLength / 2,
                            petalLength - controlPointOffset, -petalLength,
                            petalLength, 0
                        );
                        ctx.fillStyle = petalColor;
                        ctx.fill();
                        ctx.restore();
                    }
                }
            } else {
                // Dibuja las flores pequeñas con figuras geométricas
                const numPetals = 8;
                ctx.fillStyle = '#fde047';
                const petalScale = flower.bloomProgress;

                for (let i = 0; i < numPetals; i++) {
                    ctx.save();
                    const angle = (i / numPetals) * Math.PI * 2;
                    ctx.rotate(angle);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    
                    ctx.bezierCurveTo(
                        5 * petalScale, 15 * petalScale,
                        15 * petalScale, 5 * petalScale,
                        20 * petalScale, 0
                    );
                    ctx.fill();
                    ctx.restore();
                }
            }

            // Dibuja el centro de la flor
            const centerSize = 5 * flower.bloomProgress;
            ctx.fillStyle = '#f59e0b'; // Naranja para el centro
            ctx.beginPath();
            ctx.arc(0, 0, centerSize, 0, 2 * Math.PI);
            ctx.fill();

            ctx.restore();
        }

        function updateFlowers() {
            flowers.forEach(flower => {
                if (flower.currentScale < flower.targetScale) {
                    flower.currentScale += flower.growthRate;
                    if (flower.currentScale > flower.targetScale) {
                        flower.currentScale = flower.targetScale;
                    }
                }
                if (flower.bloomProgress < 1) {
                    flower.bloomProgress += flower.bloomSpeed;
                    if (flower.bloomProgress > 1) {
                        flower.bloomProgress = 1;
                    }
                }
            });
        }

        function updateStars() {
            stars.forEach(star => {
                star.twinkle += star.twinkleSpeed;
                star.alpha = Math.abs(Math.sin(star.twinkle));
            });
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            stars.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });

            flowers.forEach(flower => {
                drawFlower(flower);
            });

            updateFlowers();
            updateStars();
            
            requestAnimationFrame(animate);
        }

        function startFlowerGrowth() {
            // Creación de la flor principal
            flowers.push({
                x: width / 2,
                y: height + 5,
                targetScale: 1.5,
                currentScale: 0.1,
                growthRate: 0.003,
                rotation: 0,
                stemLength: height / 2,
                bloomProgress: 0.01,
                bloomSpeed: 0.008,
                isMain: true
            });

            // Creación de las flores pequeñas
            for (let i = 0; i < numFlowers - 1; i++) {
                setTimeout(() => {
                    flowers.push({
                        x: Math.random() * width,
                        y: height + 5,
                        targetScale: Math.random() * 0.5 + 0.3,
                        currentScale: 0.1,
                        growthRate: 0.005,
                        rotation: (Math.random() - 0.5) * 0.5,
                        stemLength: Math.random() * (height / 3) + 50,
                        bloomProgress: 0.01,
                        bloomSpeed: 0.015,
                        isMain: false
                    });
                }, i * 150 + 500); // Pequeño retraso para que la flor principal comience primero
            }
        }

        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', () => {
            resizeCanvas();
            startFlowerGrowth();
            animate();
        });
    </script>

</body>
</html>
